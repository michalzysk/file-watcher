import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.util.Collector;
import org.apache.flink.api.common.state.ListState;
import org.apache.flink.api.common.state.ListStateDescriptor;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.configuration.Configuration;

import java.util.ArrayList;
import java.util.List;

public class TrinoPollingFunction extends KeyedProcessFunction<String, MyInput, MyOutput> {

    // Stan 1: Bufor na nowe dane (Waiting Room)
    private transient ListState<MyInput> waitingState;
    
    // Stan 2: Dane aktualnie mielone przez Trino (Processing Room)
    private transient ListState<MyInput> inFlightState;
    
    // Stan 3: ID zapytania w Trino
    private transient ValueState<String> currentQueryIdState;
    
    // Stan 4: Timestamp następnego polla (żeby nie rejestrować timerów dubli)
    private transient ValueState<Long> nextPollTimerState;

    private static final long POLL_INTERVAL_MS = 5000; // Sprawdzaj co 5 sekund

    @Override
    public void open(Configuration parameters) {
        waitingState = getRuntimeContext().getListState(new ListStateDescriptor<>("waiting", MyInput.class));
        inFlightState = getRuntimeContext().getListState(new ListStateDescriptor<>("in-flight", MyInput.class));
        currentQueryIdState = getRuntimeContext().getState(new ValueStateDescriptor<>("query-id", String.class));
        nextPollTimerState = getRuntimeContext().getState(new ValueStateDescriptor<>("timer", Long.class));
        
        // Tu zainicjalizuj lekkiego klienta HTTP (np. OkHttp, Apache HttpClient)
    }

    @Override
    public void processElement(MyInput value, Context ctx, Collector<MyOutput> out) throws Exception {
        // 1. Zawsze wrzucamy do poczekalni
        waitingState.add(value);

        // 2. Jeśli nic się aktualnie nie mieli, próbujemy uruchomić nowe zapytanie
        if (currentQueryIdState.value() == null) {
            startNewQueryOrWait(ctx);
        }
        // Jeśli queryId != null, to znaczy że Trino pracuje.
        // My tylko dodaliśmy element do waitingState i kończymy. Flink jest wolny.
    }

    private void startNewQueryOrWait(Context ctx) throws Exception {
        // Przenieś dane z Waiting -> InFlight
        Iterable<MyInput> waiting = waitingState.get();
        if (waiting == null || !waiting.iterator().hasNext()) {
            return; // Bufor pusty, nic nie robimy
        }

        List<MyInput> batchToProcess = new ArrayList<>();
        waiting.forEach(batchToProcess::add);
        
        // Czyścimy waiting, zapisujemy inFlight
        waitingState.clear();
        inFlightState.update(batchToProcess);

        // --- HTTP CALL (Start Query) ---
        // To trwa milisekundy (tylko POST z treścią zapytania)
        String queryId = myHttpClient.submitQueryToTrino(batchToProcess); 
        
        currentQueryIdState.update(queryId);

        // Rejestrujemy timer na sprawdzenie statusu za 5s
        schedulePoll(ctx, POLL_INTERVAL_MS);
    }

    @Override
    public void onTimer(long timestamp, OnTimerContext ctx, Collector<MyOutput> out) throws Exception {
        String queryId = currentQueryIdState.value();
        
        if (queryId == null) {
            // Dziwny stan (np. po restarcie, jeśli logiki czyszczenia były inne),
            // ale bezpiecznie spróbujmy uruchomić nowe zapytanie jeśli są dane
            startNewQueryOrWait(ctx);
            return;
        }

        // --- HTTP CALL (Check Status) ---
        // Szybki GET po status
        TrinoStatus status = myHttpClient.getQueryStatus(queryId);

        if (status.isFinished()) {
            // A. SUKCES
            TrinoResult result = myHttpClient.fetchResults(queryId);
            
            // Pobieramy dane, które brały udział w tym zapytaniu
            Iterable<MyInput> processedInputs = inFlightState.get();
            
            // Emitujemy wyniki
            for (MyInput input : processedInputs) {
                out.collect(transform(input, result));
            }
            
            // Czyścimy stan przetwarzania
            inFlightState.clear();
            currentQueryIdState.clear();
            nextPollTimerState.clear();

            // NATYCHMIAST sprawdzamy, czy w międzyczasie coś wpadło do waitingState
            startNewQueryOrWait(ctx);

        } else if (status.isFailed()) {
            // B. PORAŻKA
            // Decyzja: Retry czy Dead Letter Queue?
            // Np. prosty retry: nie czyścimy inFlightState, tylko clearujemy queryId
            // i wołamy startNewQueryOrWait (który wyśle nowe zapytanie dla tych samych danych)
            System.err.println("Query failed, retrying...");
            currentQueryIdState.clear();
            startNewQueryOrWait(ctx); 

        } else {
            // C. W TRAKCIE (RUNNING / QUEUED)
            // Po prostu czekamy dalej.
            schedulePoll(ctx, POLL_INTERVAL_MS);
        }
    }

    private void schedulePoll(Context ctx, long delay) throws Exception {
        long nextTimer = ctx.timerService().currentProcessingTime() + delay;
        ctx.timerService().registerProcessingTimeTimer(nextTimer);
        nextPollTimerState.update(nextTimer);
    }
}
